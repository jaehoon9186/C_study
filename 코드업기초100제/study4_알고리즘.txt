
* 빅오, 오메가


* 선형 검색
정확하지만 효율적이지 못함
길이가 n일때 최악의 경우 N

정렬 x or 정보가 없이 하나씩 찾아야 하는경우

int number[] = {4,8,15, 16, 23, 42}

for(int i=0; i<6; i++){
    if(number[i] == 50){
        printf("Found\n")'
        return 0;
    }
}
printf("못찾음 \n");
return 1;


* 구조체
typeof struct{
    string name;
    string number;
}
person;

변수 a
person a;

접근
a.name
a.number


 

* 이진 검색



* 버블 정렬
빅오 n**2
오메가 n**2

두 개의 인접한 자료 값을 비교하면서 위치를 교환 하는 방식으로 정렬

조건문을 통해 하한을 단축할수있다. 
교환이 한번도 일어나지 않는다면? 
오메가 n


* 선택정렬 
빅오    n**2
오메가  n**2

배열 안의 자료 중 가장 작은 수(혹은 가장큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막위치)의 
수와  교환해 주는 방식의 정렬 


* 재귀
함수가 본인 스스로를 호출해서 사용


* 병합정렬(협병 정렬)
빅오 n log n
오메가 n log n

원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식



